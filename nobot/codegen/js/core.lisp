;;;; Copyright (c) 2021 Bohdan Sokolovskyi
;;;; Author: Bohdan Sokolovskyi <sokol.chemist@gmail.com>


(uiop:define-package :nobot/codegen/js/core
    (:use :cl
          :nobot/codegen/js/printer)
  (:import-from :alexandria
                #:curry)
  (:import-from :nobot/utils
                #:to-keyword)
  (:import-from :nobot/toplevel/context
                #:*context*
                #:get-projectgen-result
                #:get-post-processing-result)
  (:import-from :nobot/utils
                #:get-program-version
                #:get-date-now)
  (:import-from :nobot/codegen/utils
                #:with-new-file
                #:$file-stream)
  (:import-from :nobot/projectgen/common
                #:projectgen-info)
  (:import-from :nobot/botscript/post
                #:botscript-post-process-info
                #:get-bot-options
                #:get-compiler-options
                #:get-start-from-id
                #:get-var-declarations
                #:get-state-actions-declarations)
  (:import-from :nobot/codegen/top
                #:*post-process-result*
                #:generate-output-code)
  (:import-from :nobot/codegen/top
                #:*post-process-result*
                #:translate))

(in-package :nobot/codegen/js/core)

(defvar *bot-options*)
(defvar *compiler-options*)
(defvar *project-path*)

(defmethod generate-output-code (project-path (lang (eql :js)))
  (let ((*project-path* project-path)
        (*bot-options* (get-bot-options *post-process-result*))
        (*compiler-options* (get-compiler-options *post-process-result*)))
    (generate-index-file)))

(defun generate-index-file ()
  (with-new-file (*project-path* "index" :js)
    (print-js-code-from-tree
     ($file-stream)
     `(:js
       (:multi-comment
        ,(format nil "Bot ~a generated by NOBOT platform ~a in ~a~%~a"
                 (gethash :name *bot-options*)
                 (get-program-version)
                 (get-date-now)
                 (generate-rest-of-info-comment)))
       ,(generate-import)
       (:const "bot"
               (:new-object "Bot"
                            (:object
                             ("name" (:str ,(gethash :name *bot-options*)))
                             ("type" (:str ,(gethash :type *bot-options*)))
                             ("startFrom"
                              (:str ,(get-start-from-id *post-process-result*))))))
       ,(generate-storage)
       ,(generate-application)
       ,@ (generate-states)
       (:stmt
        (:chain-expr "application"
                     (:call-expr "configure"
                                 "bot")
                     (:call-expr "run")))))))

(defun generate-states ()
  (maphash
   (lambda (key value)
     `(:stmt
       (:chain-expr
        "bot"
        (:call-expr
         "on"
         (:str ,(string-downcase (string key)))
         (:arrow-fun ("inputMsg" "controller")
                     ,@(translate :js :stmt-list (third value)))))))
   (get-state-actions-declarations *post-process-result*)))

(defun generate-storage ()
  `(:stmt
    (:chain-expr "bot"
                 (:call-expr
                  "use"
                  (:object
                   ,@ (maphash
                       (lambda (key value)
                         (list (string-downcase (string key))
                               (translate :js (car value) value)))
                       (get-var-declarations *post-process-result*)))))))

;; TODO: in post rewrite str -> keyword
(defun generate-import ()
  (let ((option (gethash :@platform *compiler-options*)))
    (cond
      ((find option '("web") :test #'equal)
       '(:import ("Bot" "WebApplication") "botlib/src/wisteria.js"))
      ((find option '(:tg :telegram) :test #'equal)
       '(:import ("Bot" "TelegramApplication") "botlib/src/wisteria.js"))
      (t (error "unknown option: ~a" (string-upcase option))))))

;; TODO: in post rewrite str -> keyword
(defun generate-application ()
  (let ((option (gethash :@platform *compiler-options*)))
    `(:const "application"
             ,(cond
                ((find option '("web") :test #'equal)
                 `(:new-object "WebApplication"
                               (:object
                                ("host" (:str ,(or (gethash :host *bot-options*)
                                                   "localhost")))
                                ("port" (:num ,(or (gethash :port *bot-options*)
                                                   3000))))))
                ((find option '(:tg :telegram) :test #'equal)
                 `(:new-object "TelegramApplication"
                               (:object
                                ("token" (:str ,(gethash :token *bot-options*))))))
                (t (error "unknown option: ~a" (string-upcase option)))))))

;;TODO: try remove hard code spaces in comments
(defun generate-rest-of-info-comment ()
  (let ((author (gethash :author *bot-options*))
        (version (gethash :version *bot-options*)))
    (format nil "~a~a"
            (if author
                (format nil "   Author: ~a~%" author)
                "")
            (if version
                (format nil "   Version: ~a~%" version)
                ""))))

;;TODO rewrite with pattern-matching (see optima)
(defmethod translate ((lang (eql :js)) (sort (eql :stmt)) tree)
  `(:stmt ,(translate :js :expr (second tree))))

(defmethod translate ((lang (eql :js)) (sort (eql :stmt-list)) tree)
  (mapcar (curry #'translate :js :stmt) (cdr tree)))

(defmethod translate ((lang (eql :js)) (sort (eql :if-stmt)) tree)
  `(:if-stmt ,(translate :js :cond-expr (second tree))
             ,(translate :js :stmt-list (third tree))))

(defmethod translate ((lang (eql :js)) (sort (eql :cond-expr)) tree)
  (translate :js :logic-expr (second tree)))

(defmethod translate ((lang (eql :js)) (sort (eql :logic-expr)) tree)
  (translate :js :equal-expr (second tree)))

(defmethod translate ((lang (eql :js)) (sort (eql :equal-expr)) tree)
  `(:eq (translate :js :eql-expr (second tree))
        (translate :js :eql-expr (thord tree))))

(defmethod translate ((lang (eql :js)) (sort (eql :eql-sub-expr)) tree)
  (let ((sub-tree (second tree)))
    (translate :js (first sub-tree) sub-tree)))

(defmethod translate ((lang (eql :js)) (sort (eql :literal-or-id)) tree)
  (let ((sub-tree (second tree)))
    (translate :js (first sub-tree) sub-tree)))

(defmethod translate ((lang (eql :js)) (sort (eql :literal)) tree)
  (let ((sub-tree (second tree)))
    (translate :js (first sub-tree) sub-tree)))

(defmethod translate ((lang (eql :js)) (sort (eql :item-list)) tree)
  (mapcar (curry #'translate :js :literal) (cdr tree)))

(defmethod translate ((lang (eql :js)) (sort (eql :id)) tree)
  (second tree))

(defmethod translate ((lang (eql :js)) (sort (eql :char-string)) tree)
  `(:str ,(second tree)))

(defmethod translate ((lang (eql :js)) (sort (eql :number-string)) tree)
  `(:num ,(second tree)))

(defmethod translate ((lang (eql :js)) (sort (eql :keyword)) tree)
  (case (to-keyword (second tree))
    (:none '(:null))))

(defmethod translate ((lang (eql :js)) (sort (eql :expr)) tree)
  (let ((sub-tree (second tree)))
    (translate :js (first sub-tree) sub-tree)))

(defmethod translate ((lang (eql :js)) (sort (eql :gotov-expr)) tree)
  `(:chain-expr "controller"
                (:call-expr "next"
                            (:str ,(translate :js :id (second tree))))))

(defmethod translate ((lang (eql :js)) (sort (eql :say-expr)) tree)
  `(:chain-expr "controller"
                (:call-expr "say"
                            ,(mapcar
                              (lambda (sub-tree)
                                (translate :js (first sub-tree) sub-tree))
                              (cdr tree)))))

(defmethod translate ((lang (eql :js)) (sort (eql :save-to-expr)) tree)
  `(:chain-expr "controller"
                (:call-expr "save"
                            ,(translate :js :literal-or-id (second tree))
                            (:str ,(translate :js :id (third tree))))))
