;;;; Copyright (c) 2021 Bohdan Sokolovskyi
;;;; Author: Bohdan Sokolovskyi <sokol.chemist@gmail.com>


(uiop:define-package :nobot/codegen/js/core
    (:use :cl
          :nobot/codegen/js/printer)
  (:import-from :alexandria
                #:hash-table-alist
                #:curry)
  (:import-from :nobot/botscript/types
                #:type->keyword)
  (:import-from :nobot/utils
                #:to-keyword)
  (:import-from :nobot/toplevel/context
                #:*context*
                #:get-projectgen-result
                #:get-post-processing-result)
  (:import-from :nobot/utils
                #:get-program-version
                #:get-date-now)
  (:import-from :nobot/codegen/utils
                #:with-new-file
                #:$file-stream)
  (:import-from :nobot/projectgen/common
                #:projectgen-info)
  (:import-from :nobot/botscript/post
                #:botscript-post-process-info
                #:get-bot-options
                #:get-compiler-options
                #:get-start-from-id
                #:get-var-declarations
                #:get-state-actions-declarations)
  (:import-from :nobot/codegen/top
                #:*post-process-result*
                #:generate-output-code
                #:find-state-name)
  (:import-from :nobot/codegen/top
                #:*post-process-result*
                #:translate))

(in-package :nobot/codegen/js/core)

(defvar *bot-options*)
(defvar *compiler-options*)
(defvar *project-path*)

(defmethod generate-output-code (project-path (lang (eql :js)))
  (let ((*project-path* project-path)
        (*bot-options* (get-bot-options *post-process-result*))
        (*compiler-options* (get-compiler-options *post-process-result*)))
    (generate-index-file)))

(defun generate-index-file ()
  (with-new-file (*project-path* "index" :js)
    (print-js-code-from-tree
     ($file-stream)
     `(:js
       (:multi-comment
        ,(format nil "   Bot ~a generated by NOBOT platform ~a in ~a~%~a"
                 (gethash :name *bot-options*)
                 (get-program-version)
                 (get-date-now)
                 (generate-rest-of-info-comment)))
       ,(generate-import)
       (:const "bot"
               (:new-object "Bot"
                            (:object
                             ("name" (:str ,(gethash :name *bot-options*)))
                             ("type" (:str "chat"
                                      ;;TODO: support in future ,(gethash :type *bot-options*)
                                      ))
                             ("startFrom"
                              ;;TODO: fix this downcase
                              (:str ,(string-downcase
                                      (get-start-from-id *post-process-result*)))))))
       ,(generate-application)
       ,(generate-storage)
       ,@ (generate-states)
       (:stmt
        (:chain-expr "application"
                     (:call-expr "configure"
                                 "bot")
                     (:call-expr "run")))))))

(defun generate-states ()
  (mapcar
   (lambda (key-val)
     `(:stmt
       (:chain-expr
        "bot"
        (:call-expr
         "on"
         (:str ,(string-downcase (find-state-name (car key-val))))
         (:arrow-fun ("inputMsg" "controller")
                     ,@(translate :js :stmt-list (cdr key-val)))))))
   (hash-table-alist
    (get-state-actions-declarations *post-process-result*))))

(defun generate-storage ()
  `(:stmt
    (:chain-expr "bot"
                 (:call-expr
                  "use"
                  (:object
                   ,@ (mapcar
                       (lambda (key-val)
                         (list (format nil "\"~a\"" (string-downcase (string (car key-val))))
                               (translate :js (car (cdr key-val)) (cdr key-val))))
                       (hash-table-alist
                        (get-var-declarations *post-process-result*))))))))

;; TODO: in post rewrite str -> keyword
(defun generate-import ()
  (let ((option (gethash :@platform *compiler-options*)))
    (cond
      ((find option '("web") :test #'equal)
       '(:import ("Bot" "WebApplication") "./botlib/src/wisteria.js"))
      ((find option '("tg" "telegram") :test #'equal)
       '(:import ("Bot" "TelegramApplication") "./botlib/src/wisteria.js"))
      (t (error "unknown option: ~a" (string-upcase option))))))

;; TODO: in post rewrite str -> keyword
(defun generate-application ()
  (let ((option (gethash :@platform *compiler-options*)))
    `(:const "application"
             ,(cond
                ((find option '("web") :test #'equal)
                 `(:new-object "WebApplication"
                               (:object
                                ("host" (:str ,(or (gethash :host *bot-options*)
                                                   "localhost")))
                                ("port" (:num ,(or (gethash :port *bot-options*)
                                                   3000))))))
                ((find option '("tg" "telegram") :test #'equal)
                 `(:new-object "TelegramApplication"
                               (:object
                                ("token" (:str ,(gethash :token *bot-options*))))))
                (t (error "unknown option: ~a" (string-upcase option)))))))

;;TODO: try remove hard code spaces in comments
(defun generate-rest-of-info-comment ()
  (let ((author (gethash :author *bot-options*))
        (version (gethash :version *bot-options*)))
    (format nil "~a~a"
            (if author
                (format nil "   Author: ~a~%" author)
                "")
            (if version
                (format nil "   Version: ~a~%" version)
                ""))))

;;TODO rewrite with pattern-matching (see optima)
(defmethod translate ((lang (eql :js)) (sort (eql :stmt)) tree)
  (let ((sub-tree (second tree)))
    `(:stmt ,(translate :js (car sub-tree) sub-tree))))

(defmethod translate ((lang (eql :js)) (sort (eql :stmt-list)) tree)
  (mapcar (curry #'translate :js :stmt) (cdr tree)))

(defmethod translate ((lang (eql :js)) (sort (eql :if-stmt)) tree)
  `(:if-stmt ,(translate :js :cond-expr (second tree))
             ,(translate :js :stmt-list (third tree))
             ,(translate :js :else-block (fourth tree))))

(defmethod translate ((lang (eql :js)) (sort (eql :else-block)) tree)
  (translate :js :stmt-list (second tree)))

(defmethod translate ((lang (eql :js)) (sort (eql :cond-expr)) tree)
  (translate :js :logic-expr (second tree)))

(defmethod translate ((lang (eql :js)) (sort (eql :logic-expr)) tree)
  (translate :js :equal-expr (second tree)))

(defmethod translate ((lang (eql :js)) (sort (eql :equal-expr)) tree)
  `(:eq ,(translate :js :eql-sub-expr (second tree))
        ,(translate :js :eql-sub-expr (third tree))))

(defmethod translate ((lang (eql :js)) (sort (eql :eql-sub-expr)) tree)
  (let ((sub-tree (second tree)))
    (translate :js (first sub-tree) sub-tree)))

(defmethod translate ((lang (eql :js)) (sort (eql :literal)) tree)
  (let ((sub-tree (second tree)))
    (translate :js (first sub-tree) sub-tree)))

(defmethod translate ((lang (eql :js)) (sort (eql :item-list)) tree)
  (mapcar (curry #'translate :js :literal) (cdr tree)))

(defmethod translate ((lang (eql :js)) (sort (eql :id)) tree)
  (second tree))

;;TODO: control character! :) hello from past
(defmethod translate ((lang (eql :js)) (sort (eql :char-string)) tree)
  `(:str ,(string-trim '(#\") (second tree))))

(defmethod translate ((lang (eql :js)) (sort (eql :number-string)) tree)
  `(:num ,(second tree)))

(defmethod translate ((lang (eql :js)) (sort (eql :keyword)) tree)
  (let ((kword (to-keyword (second tree))))
    (case kword
      (:none '(:null))
      (:?input "inputMsg")
      (t (error "unknown keyword: ~a" kword)))))

(defmethod translate ((lang (eql :js)) (sort (eql :expr)) tree)
  (let ((sub-tree (second tree)))
    (translate :js (first sub-tree) sub-tree)))

(defmethod translate ((lang (eql :js)) (sort (eql :gotov-expr)) tree)
  `(:chain-expr "controller"
                (:call-expr "next"
                            (:str ,(translate :js :id (second tree))))))

(defmethod translate ((lang (eql :js)) (sort (eql :say-expr)) tree)
  `(:chain-expr "controller"
                (:call-expr "say"
                            (:template-str
                             ,@(mapcar
                                (lambda (sub-tree)
                                  (if (eq (type->keyword (car sub-tree)) :id)
                                      `(:chain-expr "controller"
                                                    (:call-expr "get"
                                                                (:str ,(second sub-tree))))
                                      (translate :js (first sub-tree) sub-tree)))
                                (cdr tree))))))

(defmethod translate ((lang (eql :js)) (sort (eql :save-to-expr)) tree)
  (let ((sub-tree (second tree)))
    `(:chain-expr "controller"
                  (:call-expr "save"
                              ,(translate :js (car sub-tree) sub-tree)
                              (:str ,(translate :js :id (third tree)))))))
